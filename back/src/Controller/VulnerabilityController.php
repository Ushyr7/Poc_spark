<?php

namespace App\Controller;

use App\Entity\Perimeter;
use App\Entity\Vulnerability;
use App\Repository\PerimeterRepository;
use App\Repository\VulnerabilityRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Doctrine\ORM\EntityManagerInterface;




class VulnerabilityController extends AbstractController
{
    private PerimeterRepository $perimeterRepository;
    private VulnerabilityRepository $vulnerabilityRepository;
    private EntityManagerInterface $entityManager;

    public function __construct(PerimeterRepository $perimeterRepository, VulnerabilityRepository $vulnerabilityRepository, EntityManagerInterface $entityManager) {
        $this->perimeterRepository = $perimeterRepository;
        $this->vulnerabilityRepository = $vulnerabilityRepository;
        $this->entityManager = $entityManager;
    }

    #[Route('/vulnerability', name: 'vulnerability_index', methods: ['GET'])]
    public function index(Request $request): JsonResponse
    {
        $page = $request->query->getInt('page', 1);
        $limit = $request->query->getInt('limit', 10);

        if ($page <= 0) {
            return new JsonResponse(['error' => 'page number must be positive'], Response::HTTP_BAD_REQUEST);
        }
        if ($limit <= 0) {
            return new JsonResponse(['error' => 'limit must be positive'], Response::HTTP_BAD_REQUEST);
        }

        $paginator = $this->vulnerabilityRepository->getVulnerabilitiesPaginator($page, $limit);
        $vulnerabilities = $paginator->getIterator();

        $data = [];
        foreach ($vulnerabilities as $vulnerability) {
            $data[] = [
                'id' => $vulnerability->getId()->toString(),
                'template' => $vulnerability->getTemplate(),
                'description' => $vulnerability->getDescription(),
                'name' => $vulnerability->getName(),
                'reference' => $vulnerability->getReference(),
                'severity' => $vulnerability->getSeverity(),
                'matched_at' => $vulnerability->getMatchedAt(),
                'timestamp' => $vulnerability->getTimestamp()?->format(\DateTimeInterface::ATOM),
                'ip' => $vulnerability->getIp(),
                'perimeter' => $vulnerability->getPerimeter()->getId()->toString(),
                'solution_found' => $vulnerability->getSolutionFound(),
                'status' => $vulnerability->getStatus(),
            ];
        }

        return new JsonResponse([
            'items' => $data,
            'total_count' => $paginator->count(),
            'page_count' => ceil($paginator->count() / $limit),
            'current_page' => $page,
        ]);
    }

    #[Route('/perimeter/{id}/vulnerability', name: 'vulnerabilityPerPerimeter_index', methods: ['GET'])]
    public function getVulnerabilitiesByPerimeter(Request $request, Perimeter $perimeter = null): JsonResponse
    {
        if (!$perimeter) {
            return new JsonResponse(['error' => 'perimeter not found'], Response::HTTP_BAD_REQUEST);

        }

        // Pagination parameters
        $page = $request->query->getInt('page', 1);
        $limit = $request->query->getInt('limit', 10);

        if ($page <= 0) {
            return new JsonResponse(['error' => 'page number must be positive'], Response::HTTP_BAD_REQUEST);
        }
        if ($limit <= 0) {
            return new JsonResponse(['error' => 'limit must be positive'], Response::HTTP_BAD_REQUEST);
        }

        // Fetch paginated vulnerabilities
        $paginator = $this->vulnerabilityRepository->findPaginatedByPerimeter($perimeter, $page, $limit);
        $vulnerabilities = $paginator->getIterator();

        $data = [];
        foreach ($vulnerabilities as $vulnerability) {
            $data[] = [
                'id' => $vulnerability->getId()->toString(),
                'template' => $vulnerability->getTemplate(),
                'description' => $vulnerability->getDescription(),
                'name' => $vulnerability->getName(),
                'reference' => $vulnerability->getReference(),
                'severity' => $vulnerability->getSeverity(),
                'matched_at' => $vulnerability->getMatchedAt(),
                'timestamp' => $vulnerability->getTimestamp()?->format(\DateTimeInterface::ATOM),
                'ip' => $vulnerability->getIp(),
                'perimeter' => $vulnerability->getPerimeter()->getId()->toString(),
                'solution_found' => $vulnerability->getSolutionFound(),
                'status' => $vulnerability->getStatus(),
            ];
        }

        return new JsonResponse([
            'items' => $data,
            'total_count' => $paginator->count(),
            'page_count' => ceil($paginator->count() / $limit),
            'current_page' => $page,
        ]);
    }

    #[Route('/vulnerability/{id}', name: 'vulnerability_delete', methods: ['DELETE'])]
    public function delete(Vulnerability $vulnerability = null): JsonResponse
    {
        if (!$vulnerability) {
            return new JsonResponse(['error' => 'vulnerability not found'], Response::HTTP_NOT_FOUND);
        }

        // Modify the status to "hidden"
        $vulnerability->setStatus('hidden');

        $entityManager = $this->getDoctrine()->getManager();
        $entityManager->persist($vulnerability);
        $entityManager->flush();

        return new JsonResponse(['message' => 'Vulnerability marked as hidden']);
    }

    #[Route('/vulnerability/{id}', name: 'vulnerability_show', methods: ['GET'])]
    public function showVulnerability(Vulnerability $vulnerability = null): JsonResponse
    {
        if (!$vulnerability) {
            return new JsonResponse(['error' => 'Vulnerability not found'], Response::HTTP_NOT_FOUND);
        }

        $data = [
            'id' => $vulnerability->getId()->toString(),
            'template' => $vulnerability->getTemplate(),
            'description' => $vulnerability->getDescription(),
            'name' => $vulnerability->getName(),
            'reference' => $vulnerability->getReference(),
            'severity' => $vulnerability->getSeverity(),
            'matched_at' => $vulnerability->getMatchedAt(),
            'timestamp' => $vulnerability->getTimestamp()?->format(\DateTimeInterface::ATOM),
            'ip' => $vulnerability->getIp(),
            'perimeter' => $vulnerability->getPerimeter()->getId()->toString(),
            'solution_found' => $vulnerability->getSolutionFound(),
            'status' => $vulnerability->getStatus(),
        ];

        return new JsonResponse($data);
    }

    #[Route('/vulnerability/stats', name: 'vulnerability_stats', methods: ['GET'])]
    public function vulnerabilityStats(VulnerabilityRepository $vulnerabilityRepository): JsonResponse
    {
        $hiddenCount = $vulnerabilityRepository->countByStatus('hidden');
        $solvedCount = $vulnerabilityRepository->countByStatus('solved');
        $criticalCount = $vulnerabilityRepository->countBySeverity('critical');

        return new JsonResponse([
            'hidden_count' => $hiddenCount,
            'solved_count' => $solvedCount,
            'critical_count' => $criticalCount,
        ]);
    }


}
